/**
 * DebugLogger.ts
 * {{PLUGIN_NAME}}
 *
 * Centralized debug logging service for Stream Deck plugins
 * - In DEVELOPMENT: Logs to Stream Deck logger + file
 * - In PRODUCTION: No-op stubs (tree-shaken by bundler)
 * - No need for conditional checks at call sites!
 *
 * Auto-generated by /init-workspace
 */

import streamDeck from "@elgato/streamdeck";
import { WriteFile } from "@elgato/streamdeck";

/** Log categories for filtering and organization */
export enum LogCategory {
	App = "App",
	Action = "Action",
	PropertyInspector = "PropertyInspector",
	Settings = "Settings",
	Network = "Network",
	General = "General"
}

const IS_DEVELOPMENT = process.env.NODE_ENV === "development";

/**
 * Enhanced debug logger for Stream Deck plugins
 * Leverages built-in streamDeck.logger with additional features
 */
class DebugLoggerService {
	private logFilePath = "debug.log";
	private logs: string[] = [];

	/**
	 * Log a general message with optional category
	 */
	log(message: string, category: LogCategory = LogCategory.General): void {
		if (!IS_DEVELOPMENT) return;

		const formatted = this.formatMessage("DEBUG", message, category);
		streamDeck.logger.debug(formatted);
		this.writeToFile(formatted);
	}

	/**
	 * Log an info message
	 */
	info(message: string, category: LogCategory = LogCategory.General): void {
		if (!IS_DEVELOPMENT) return;

		const formatted = this.formatMessage("INFO", message, category);
		streamDeck.logger.info(formatted);
		this.writeToFile(formatted);
	}

	/**
	 * Log a warning message
	 */
	warning(message: string, category: LogCategory = LogCategory.General): void {
		const formatted = this.formatMessage("WARN", message, category);
		streamDeck.logger.warn(formatted);
		if (IS_DEVELOPMENT) {
			this.writeToFile(formatted);
		}
	}

	/**
	 * Log an error message
	 */
	error(message: string, category: LogCategory = LogCategory.General): void {
		const formatted = this.formatMessage("ERROR", message, category);
		streamDeck.logger.error(formatted);
		if (IS_DEVELOPMENT) {
			this.writeToFile(formatted);
		}
	}

	/**
	 * Log a separator for visual organization
	 */
	separator(): void {
		if (!IS_DEVELOPMENT) return;

		const sep = "-".repeat(80);
		streamDeck.logger.debug(sep);
		this.writeToFile(sep);
	}

	/**
	 * Format log message with timestamp and category
	 */
	private formatMessage(level: string, message: string, category: LogCategory): string {
		const timestamp = new Date().toISOString();
		return `[${timestamp}] [${level}] [${category}] ${message}`;
	}

	/**
	 * Write log message to file (development only)
	 */
	private writeToFile(message: string): void {
		if (!IS_DEVELOPMENT) return;

		this.logs.push(message);

		// Flush to file periodically (every 10 messages or on errors)
		if (this.logs.length >= 10 || message.includes("[ERROR]")) {
			this.flush();
		}
	}

	/**
	 * Flush accumulated logs to file
	 */
	private async flush(): Promise<void> {
		if (this.logs.length === 0) return;

		const content = this.logs.join("\n") + "\n";
		this.logs = [];

		try {
			await streamDeck.plugin.fetch(WriteFile, {
				path: this.logFilePath,
				payload: content,
				append: true
			});
		} catch (err) {
			streamDeck.logger.error(`Failed to write to log file: ${err}`);
		}
	}

	/**
	 * Clear the log file
	 */
	async clearLogFile(): Promise<void> {
		if (!IS_DEVELOPMENT) return;

		try {
			await streamDeck.plugin.fetch(WriteFile, {
				path: this.logFilePath,
				payload: `=== {{PLUGIN_NAME}} Debug Log ===\nStarted: ${new Date().toISOString()}\n` + "=".repeat(50) + "\n\n"
			});
			streamDeck.logger.info("Debug log file cleared");
		} catch (err) {
			streamDeck.logger.error(`Failed to clear log file: ${err}`);
		}
	}
}

// Export singleton instance
export const logger = new DebugLoggerService();

// Clear log file on plugin start (development only)
if (IS_DEVELOPMENT) {
	logger.clearLogFile();
}
