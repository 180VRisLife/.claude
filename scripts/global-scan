#!/bin/bash
# Global Developer folder scanner for Claude Code
# Usage: global-scan [git|init|both]
#
# Scans the Developer folder for:
# - Git repos with uncommitted changes
# - CLAUDE.md files needing updates
# - Broken symlinks
#
# Outputs structured data for the /global command to parse

set -eo pipefail

DEVELOPER_DIR="/Users/chrisjamesbliss/Developer"
MODE="${1:-both}"

# Arrays to track results
declare -a ALL_REPOS=()
declare -a REPOS_NEEDING_GIT=()
declare -a REPOS_NEEDING_INIT=()
declare -a REPOS_CLEAN=()
declare -a SYMLINKS_VALID=()
declare -a SYMLINKS_UNAVAILABLE=()
declare -a SYMLINKS_BROKEN=()
declare -a NON_GIT_DIRS=()

# Output array helper - reduces repeated pattern
output_array() {
    local label="$1" prefix="$2"
    shift 2
    local arr=("$@")
    echo "${label}:${#arr[@]}"
    for item in "${arr[@]}"; do
        echo "${prefix}:${item}"
    done
}

# Discover all git repositories and check symlinks
# This function modifies global arrays directly (no subshell)
discover_repos_and_symlinks() {
  # Direct repos in Versioned/
  if [ -d "${DEVELOPER_DIR}/Versioned" ]; then
    for dir in "${DEVELOPER_DIR}/Versioned"/*; do
      if [ -d "${dir}/.git" ]; then
        ALL_REPOS+=("${dir}")
      fi
    done
  fi

  # Check symlinks in Unversioned/ and Workspaces/
  for base_dir in "${DEVELOPER_DIR}/Unversioned" "${DEVELOPER_DIR}/Workspaces"; do
    if [ -d "${base_dir}" ]; then
      for link in "${base_dir}"/*; do
        if [ -L "${link}" ]; then
          local target
          target=$(readlink "${link}" 2>/dev/null || true)
          local name
          name=$(basename "${link}")

          if [ -z "${target}" ]; then
            SYMLINKS_BROKEN+=("${name}|${link}|unknown")
          elif [[ "${target}" == /Volumes/* ]] && [ ! -d "${target}" ]; then
            SYMLINKS_UNAVAILABLE+=("${name}|${link}|${target}")
          elif [ ! -e "${target}" ]; then
            SYMLINKS_BROKEN+=("${name}|${link}|${target}")
          else
            SYMLINKS_VALID+=("${name}|${link}|${target}")
            if [ -d "${target}/.git" ]; then
              ALL_REPOS+=("${target}")
            fi
          fi
        fi
      done
    fi
  done

  # Deduplicate repos (sort-based O(n log n), bash 3 compatible)
  local unique_repos=()
  local seen_file
  seen_file=$(mktemp)
  for repo in "${ALL_REPOS[@]}"; do
    local canonical
    canonical=$(cd "${repo}" 2>/dev/null && pwd -P || echo "${repo}")
    if ! grep -qxF "${canonical}" "${seen_file}" 2>/dev/null; then
      echo "${canonical}" >> "${seen_file}"
      unique_repos+=("${repo}")
    fi
  done
  rm -f "${seen_file}"
  ALL_REPOS=("${unique_repos[@]}")
}

# Check git status for a repo
check_git_status() {
  local repo="$1"
  local name
  name=$(basename "${repo}")

  cd "${repo}" 2>/dev/null || return 1

  local branch
  branch=$(git branch --show-current 2>/dev/null || echo "unknown")
  local status
  status=$(git status --porcelain 2>/dev/null || true)
  local ahead
  ahead=$(git rev-list --count '@{u}..HEAD' 2>/dev/null || echo "0")

  if [ -n "${status}" ] || [ "${ahead}" -gt 0 ]; then
    local count
    count=$(echo "${status}" | grep -c . || echo "0")
    echo "${name}|${branch}|${count}|${ahead}|${repo}"
    return 0
  fi

  return 1
}

# Check CLAUDE.md status for a repo
check_init_status() {
  local repo="$1"
  local name
  name=$(basename "${repo}")
  local claude_file="${repo}/CLAUDE.md"

  if [ ! -f "${claude_file}" ]; then
    echo "${name}|missing|0|${repo}"
    return 0
  fi

  # Check freshness: compare CLAUDE.md mtime vs last git commit
  local claude_mtime
  claude_mtime=$(stat -f %m "${claude_file}" 2>/dev/null || echo "0")
  local last_commit
  last_commit=$(git -C "${repo}" log -1 --format=%ct 2>/dev/null || echo "0")

  if [ "${last_commit}" -gt "${claude_mtime}" ]; then
    local days_old
    days_old=$(( (last_commit - claude_mtime) / 86400 ))
    echo "${name}|stale|${days_old}|${repo}"
    return 0
  fi

  # Check size
  local size
  size=$(wc -c < "${claude_file}" | tr -d ' ')
  if [ "${size}" -lt 500 ]; then
    echo "${name}|incomplete|${size}|${repo}"
    return 0
  fi

  return 1
}

# Check for non-git directories with code
check_non_git_dirs() {
  local base_dir="${DEVELOPER_DIR}/Unversioned"
  if [ -d "${base_dir}" ]; then
    for dir in "${base_dir}"/*; do
      # Follow symlinks to actual directory
      local actual_dir="${dir}"
      if [ -L "${dir}" ]; then
        actual_dir=$(readlink "${dir}" 2>/dev/null || true)
      fi

      if [ -n "${actual_dir}" ] && [ -d "${actual_dir}" ] && [ ! -d "${actual_dir}/.git" ]; then
        # Check if it has code files (use find instead of ls for robustness)
        if find "${actual_dir}" -maxdepth 1 -type f \( -name "*.py" -o -name "*.swift" -o -name "*.ts" -o -name "*.js" -o -name "*.lua" \) 2>/dev/null | head -1 | grep -q .; then
          local name
          name=$(basename "${dir}")
          NON_GIT_DIRS+=("${name}|${actual_dir}")
        fi
      fi
    done
  fi
}

# Main execution
main() {
  echo "SCAN_START"
  echo "MODE:${MODE}"

  # Discover repos and symlinks (modifies global arrays)
  discover_repos_and_symlinks

  # Output symlink status
  output_array "SYMLINKS_VALID" "SYM_OK" "${SYMLINKS_VALID[@]}"
  output_array "SYMLINKS_UNAVAILABLE" "SYM_NA" "${SYMLINKS_UNAVAILABLE[@]}"
  output_array "SYMLINKS_BROKEN" "SYM_BROKEN" "${SYMLINKS_BROKEN[@]}"

  # Git analysis
  if [ "${MODE}" = "git" ] || [ "${MODE}" = "both" ]; then
    for repo in "${ALL_REPOS[@]}"; do
      local result
      result=$(check_git_status "${repo}" || true)
      if [ -n "${result}" ]; then
        REPOS_NEEDING_GIT+=("${result}")
      else
        REPOS_CLEAN+=("$(basename "${repo}")")
      fi
    done

    output_array "GIT_NEEDS" "GIT" "${REPOS_NEEDING_GIT[@]}"
    output_array "GIT_CLEAN" "CLEAN" "${REPOS_CLEAN[@]}"
  fi

  # CLAUDE.md analysis
  if [ "${MODE}" = "init" ] || [ "${MODE}" = "both" ]; then
    for repo in "${ALL_REPOS[@]}"; do
      local result
      result=$(check_init_status "${repo}" || true)
      if [ -n "${result}" ]; then
        REPOS_NEEDING_INIT+=("${result}")
      fi
    done

    output_array "INIT_NEEDS" "INIT" "${REPOS_NEEDING_INIT[@]}"
  fi

  # Check for non-git directories
  check_non_git_dirs
  output_array "NON_GIT" "NOGIT" "${NON_GIT_DIRS[@]}"

  echo "SCAN_END"
}

main
