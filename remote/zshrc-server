# Server zshrc (synced from local via _sync_claude_config)
# Combines 00-core, 10-claude, 20-tmux, 40-help adapted for Linux

# =============================================================================
# CORE (from 00-core.zsh)
# =============================================================================

alias pip='python3 -m pip'

# PATH is set in ~/.zshenv (sourced for all zsh invocations, including non-interactive)

# Editor (nano on server, was "open -e -W -n" on macOS)
export EDITOR="nano"

# Prompt git info (mirrors statusline format: [rp] repo:branch✓ in steel blue)
# No workspace [ws] detection (workspaces not on server)
_prompt_git_info() {
  _git_prompt=""
  local branch
  branch=$(git branch --show-current 2>/dev/null) || return
  if [[ -n "$branch" ]]; then
    local dirty
    [[ -n "$(git status --porcelain 2>/dev/null)" ]] && dirty="*" || dirty="✓"
    if [[ -f "$(git rev-parse --show-toplevel 2>/dev/null)/.git" ]]; then
      # Worktree: .git is a file
      local folder=$(basename "$PWD")
      _git_prompt=" %F{244}|%f %F{67}[wt] ${folder}:${branch}${dirty}%f"
    else
      # Regular repo
      local repo_root=$(git rev-parse --show-toplevel 2>/dev/null)
      local repo_name=$(basename "$repo_root")
      _git_prompt=" %F{244}|%f %F{67}[rp] ${repo_name}:${branch}${dirty}%f"
    fi
  fi
}
precmd_functions+=(_prompt_git_info)

setopt PROMPT_SUBST
PROMPT='%F{173}[remote]%f %F{244}|%f %F{109}%2~%f${_git_prompt} %# '

# Terminal title: folder_name (non-tmux only)
set_terminal_title() {
  [[ -n "$TMUX" ]] && return
  print -Pn "\e]0;[R] $(basename "$PWD")\a"
}
precmd_functions+=(set_terminal_title)
set_terminal_title

# =============================================================================
# CLAUDE (from 10-claude.zsh, no keychain wrapper)
# =============================================================================

c() { command claude; }
cr() { command claude --resume; }
cc() { command claude --continue; }
ct() { command claude --teammate-mode tmux; }

# Beacon phone notification toggle
beacon() {
  local mode_file="$HOME/.beacon/mode"
  case "${1:-status}" in
    on|off|auto)
      echo "$1" > "$mode_file"
      echo "Beacon: $1"
      ;;
    status)
      echo "Beacon: $(cat "$mode_file" 2>/dev/null || echo auto)"
      ;;
    *) echo "Usage: beacon [on|off|auto|status]" ;;
  esac
}

# Beacon SSH auto-attach (remote server)
if [[ -n "$SSH_CONNECTION" && -z "$TMUX" ]]; then
  _beacon_auto_attach() {
    setopt local_options NULL_GLOB
    local target_dir="$HOME/.beacon/targets"
    [[ -d "$target_dir" ]] || return

    local -a targets
    for f in "$target_dir"/*(Om); do  # Om = sort by mtime, newest first
      [[ -f "$f" ]] && targets+=("$f")
    done

    if (( ${#targets[@]} >= 1 )); then
      local session=$(<"${targets[1]}")
      rm -f "${targets[1]}"
      exec tmux attach -t "$session" 2>/dev/null || exec tmux attach
    fi
  }
  _beacon_auto_attach
  unfunction _beacon_auto_attach
fi

# =============================================================================
# TMUX (from 20-tmux.zsh, date -d @ for GNU/Linux)
# =============================================================================

# Cleanup numbered sessions when base name becomes available
_cleanup_session_names() {
  local sessions=$(tmux ls -F '#{session_name}' 2>/dev/null) || return

  echo "$sessions" | grep -E '^.+-[0-9]+( - .+)?$' | while read -r numbered; do
    local osc_suffix=""
    local core="$numbered"

    if [[ "$numbered" =~ ^(.+)(' - '.+)$ ]]; then
      core="${match[1]}"
      osc_suffix="${match[2]}"
    fi

    if [[ "$core" =~ ^(.+)-([0-9]+)$ ]]; then
      local base="${match[1]}"
      local target="${base}${osc_suffix}"

      if ! echo "$sessions" | grep -qxF "$target"; then
        tmux rename-session -t "$numbered" "$target" 2>/dev/null
        sessions=$(tmux ls -F '#{session_name}' 2>/dev/null)
      fi
    fi
  done
}

# Get unique session name ([R] prefixed for remote)
_unique_session_name() {
  local base="${1:-$(basename $PWD)}"
  base="${base#.}"

  _cleanup_session_names

  local sessions=$(tmux ls -F '#{session_name}' 2>/dev/null)

  if ! echo "$sessions" | grep -qxF "[R] $base"; then
    echo "[R] $base"
    return
  fi

  local n=1
  while echo "$sessions" | grep -qxF "[R] ${base}-${n}"; do
    ((n++))
  done
  echo "[R] ${base}-${n}"
}

# Get running process for a session
_session_process() {
  local session="$1"
  tmux list-panes -t "$session" -F '#{pane_current_command}' 2>/dev/null | head -1
}

# Format session for display: "name (process)"
_format_session() {
  local session="$1"
  local proc=$(_session_process "$session")
  echo "$session ($proc)"
}

# Get session name by tls number (activity-sorted order)
_session_by_number() {
  local num="$1"
  tmux ls -F '#{session_activity}|#{session_name}' 2>/dev/null | \
    sort -t'|' -k1 -rn | \
    awk -F'|' -v n="$num" 'NR==n {print $2}'
}

# Start new tmux session
t() {
  if [[ -n "$TMUX" ]]; then
    echo "Already in tmux. Use 'td' to detach first."
  else
    local name="$(_unique_session_name)"
    echo "→ $name"
    tmux new -s "$name"
  fi
}

# Start new tmux session and launch Claude Code
tc() {
  if [[ -n "$TMUX" ]]; then
    clear && tmux clear-history && claude
  else
    local name="$(_unique_session_name)"
    echo "→ $name"
    tmux new -s "$name" 'claude; exec $SHELL'
  fi
}

# Start new tmux session and resume last Claude conversation
tcr() {
  if [[ -n "$TMUX" ]]; then
    clear && tmux clear-history && claude --resume
  else
    local name="$(_unique_session_name)"
    echo "→ $name"
    tmux new -s "$name" 'claude --resume; exec $SHELL'
  fi
}

# Start new tmux session and continue last Claude conversation
tcc() {
  if [[ -n "$TMUX" ]]; then
    clear && tmux clear-history && claude --continue
  else
    local name="$(_unique_session_name)"
    echo "→ $name"
    tmux new -s "$name" 'claude --continue; exec $SHELL'
  fi
}

# Start Claude in team mode
tct() { ct; }

# List sessions (sorted by activity, most recent first)
# Uses GNU date -d @ (not BSD date -r)
tls() {
  _cleanup_session_names
  local output
  output=$(tmux ls -F '#{session_activity}|#{?session_attached,*,}|#{session_name}' 2>/dev/null | \
    sort -t'|' -k1 -rn | awk -F'|' '{
      cmd = "date -d @" $1 " +\"%m/%d %H:%M\""
      cmd | getline ts
      close(cmd)
      n = NR
      if ($2 == "*") { print n ". " ts "    [attached]" }
      else { print n ". " ts }
      print "\"" $3 "\""
      print ""
    }')
  if [[ -z "$output" ]]; then
    echo "No sessions"
    echo "t=new  tc=claude  tcr=resume"
  else
    echo "TMUX SESSIONS"
    echo ""
    echo "$output"
  fi
}

alias td="tmux detach"

# Attach to session (last used, by number from tls, or by name)
ta() {
  _cleanup_session_names
  if [[ -n "$1" ]]; then
    local target="$1"

    if [[ "$1" =~ ^[0-9]+$ ]]; then
      target=$(_session_by_number "$1")
      if [[ -z "$target" ]]; then
        echo "No session at position $1"
        echo "Run 'tls' to see available sessions"
        return 1
      fi
    fi

    if ! tmux has-session -t "$target" 2>/dev/null; then
      echo "Session not found: $target"
      echo "Run 'tls' to see available sessions"
      return 1
    fi
    local session_dir=$(tmux display-message -p -t "$target" '#{pane_current_path}' 2>/dev/null)
    [[ -n "$session_dir" && -d "$session_dir" ]] && cd "$session_dir"
    tmux attach -t "$target"
  else
    if ! tmux ls &>/dev/null; then
      echo "No sessions. Use 't' or 'tc' to start one."
      return 1
    fi
    local last_session=$(tmux ls -F '#{session_activity}|#{session_name}' 2>/dev/null | sort -t'|' -k1 -rn | head -1 | cut -d'|' -f2)
    local session_dir=$(tmux display-message -p -t "$last_session" '#{pane_current_path}' 2>/dev/null)
    [[ -n "$session_dir" && -d "$session_dir" ]] && cd "$session_dir"
    tmux attach
  fi
}

# Kill current session (with confirmation)
tq() {
  local name=$(tmux display-message -p '#{session_name}' 2>/dev/null)
  if [[ -z "$name" ]]; then
    echo "Not in a tmux session"
    return 1
  fi
  local display=$(_format_session "$name")
  echo -n "Kill $display? (y/N) "
  read reply && [[ "$reply" =~ ^[Yy]$ ]] && { tmux kill-session; echo "Killed: $name"; }
}

# Kill specific session(s)
tks() {
  if [[ -z "$1" ]]; then
    echo "Usage: tks <session> [session2] [session3] ..."
    echo "       Sessions can be numbers (from tls) or names"
    return 1
  fi

  local valid=()
  local invalid=()
  for arg in "$@"; do
    local session="$arg"

    if [[ "$arg" =~ ^[0-9]+$ ]]; then
      session=$(_session_by_number "$arg")
      if [[ -z "$session" ]]; then
        invalid+=("position $arg")
        continue
      fi
    fi

    if tmux has-session -t "$session" 2>/dev/null; then
      valid+=("$session")
    else
      invalid+=("$session")
    fi
  done

  if [[ ${#invalid[@]} -gt 0 ]]; then
    for session in "${invalid[@]}"; do
      echo "Session not found: $session"
    done
    [[ ${#valid[@]} -eq 0 ]] && return 1
  fi

  if [[ ${#valid[@]} -eq 1 ]]; then
    local display=$(_format_session "${valid[1]}")
    echo -n "Kill $display? (y/N) "
  else
    echo "Kill ${#valid[@]} session(s)?"
    for session in "${valid[@]}"; do
      echo "  $(_format_session "$session")"
    done
    echo -n "(y/N) "
  fi

  read reply && [[ "$reply" =~ ^[Yy]$ ]] && {
    for session in "${valid[@]}"; do
      tmux kill-session -t "$session"
      echo "Killed: $session"
    done
  }
}

# Kill all detached sessions
tkd() {
  local detached=()
  while IFS= read -r line; do
    [[ -n "$line" ]] && detached+=("$line")
  done < <(tmux ls -F '#{session_attached}|#{session_name}' 2>/dev/null | awk -F'|' '$1==0 {print $2}')

  if [[ ${#detached[@]} -eq 0 ]]; then
    echo "No detached sessions"
    return
  fi

  echo "Kill ${#detached[@]} detached session(s)?"
  for session in "${detached[@]}"; do
    echo "  $(_format_session "$session")"
  done
  echo -n "(y/N) "
  read reply && [[ "$reply" =~ ^[Yy]$ ]] && {
    for session in "${detached[@]}"; do
      tmux kill-session -t "$session"
      echo "Killed: $session"
    done
  }
}

# Kill all sessions
tkill() {
  local sessions=()
  while IFS= read -r line; do
    [[ -n "$line" ]] && sessions+=("$line")
  done < <(tmux ls -F '#{session_name}' 2>/dev/null)
  if [[ ${#sessions[@]} -eq 0 ]]; then
    echo "No sessions to kill"
    return
  fi
  echo "Kill all ${#sessions[@]} session(s)?"
  for session in "${sessions[@]}"; do
    echo "  $(_format_session "$session")"
  done
  echo -n "(y/N) "
  read reply && [[ "$reply" =~ ^[Yy]$ ]] && { tmux kill-server; echo "Killed ${#sessions[@]} session(s)"; }
}

# =============================================================================
# HELP (from 40-help.zsh, Claude + Tmux sections only)
# =============================================================================

h() {
  local t=$'\e[38;5;109m'  # teal (headers)
  local b=$'\e[38;5;67m'   # blue (commands)
  local g=$'\e[38;5;244m'  # gray (dim/hints)
  local r=$'\e[0m'         # reset
  local rule="${g}──────────────────────────────────────────${r}"

  print "${t}CLAUDE${r}"
  print "$rule"
  print "  ${b}c${r}       Claude"
  print "  ${b}cr${r}      Claude --resume"
  print "  ${b}cc${r}      Claude --continue"
  print "  ${b}ct${r}      Claude team mode"
  print "  ${b}beacon${r}                   ${g}on / off / auto / status${r}"
  print ""
  print "${t}TMUX${r}"
  print "$rule"
  print "  ${g}sessions${r}"
  print "  ${b}t${r}       New session"
  print "  ${b}tc${r}      New + Claude"
  print "  ${b}tcr${r}     New + Claude --resume"
  print "  ${b}tcc${r}     New + Claude --continue"
  print "  ${b}tct${r}     New + Claude team mode"
  print "  ${b}ta${r}      Attach ${g}N${r} or ${g}name${r}"
  print "  ${b}tls${r}     List sessions"
  print ""
  print "  ${g}lifecycle${r}"
  print "  ${b}td${r}      Detach"
  print "  ${b}tq${r}      Kill current"
  print "  ${b}tks${r}     Kill specific ${g}N${r} ${g}[N...]${r}"
  print "  ${b}tkd${r}     Kill all detached"
  print "  ${b}tkill${r}   Kill all"
  print ""
  print "${t}TOOLS${r}"
  print "$rule"
  print "  ${g}navigation${r}"
  print "  ${b}z${r}       Jump to directory        ${g}learned from cd history${r}"
  print "  ${b}Ctrl+T${r}  Find file                ${g}fuzzy search, preview${r}"
  print "  ${b}Ctrl+R${r}  Search history           ${g}fuzzy shell history${r}"
  print ""
  print "  ${g}files${r}"
  print "  ${b}cat${r}     View file                ${g}syntax highlighted (bat)${r}"
  print "  ${b}rg${r}      Search code              ${g}fast regex search (ripgrep)${r}"
  print ""
  print "  ${g}reference${r}"
  print "  ${b}tldr${r}    Quick help               ${g}simplified man pages${r}"
  print ""
}

# =============================================================================
# ZSH AUTOSUGGESTIONS (apt package path)
# =============================================================================

if [[ -f /usr/share/zsh-autosuggestions/zsh-autosuggestions.zsh ]]; then
  source /usr/share/zsh-autosuggestions/zsh-autosuggestions.zsh
  ZSH_AUTOSUGGEST_STRATEGY=(history completion)
  ZSH_AUTOSUGGEST_USE_ASYNC=true
  bindkey '\t' autosuggest-accept      # Tab to accept
  bindkey '\e\t' complete-word          # Option+Tab for completion menu
fi
